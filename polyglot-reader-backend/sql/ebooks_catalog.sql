-- Ebook catalog tables for Polyglot Reader (Approach 2: DB-backed catalog).
-- Compatible with Supabase Postgres.
--
-- What this enables:
-- - Background ingestion/sync from external libraries into Postgres
-- - Fast, scalable pagination from your own DB (no "pool" limit per request)
-- - Precomputed category/author counts for fast Library overview rendering

-- Core catalog items (deduped by a stable id generated by the backend).
create table if not exists public.ebook_catalog_items (
  -- Stable id used by the mobile app as the ebook id. Backend generates this (dedupe key).
  id text primary key,

  lang_code text not null,
  title text not null,
  author text not null,
  category text not null,

  cover_url text,
  download_url text not null,

  -- Which upstream library provided the selected download_url/metadata.
  source text not null,
  source_id text,

  -- Optional: numeric popularity signal from the source (e.g., Gutendex download_count, Wikisource views).
  source_popularity integer,

  -- Normalized fields for stable matching / case-insensitive queries.
  author_norm text not null,
  title_norm text not null,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  last_seen_at timestamptz not null default now()
);

create index if not exists ebook_catalog_items_lang_category_idx
  on public.ebook_catalog_items(lang_code, category);

create index if not exists ebook_catalog_items_lang_author_norm_idx
  on public.ebook_catalog_items(lang_code, author_norm);

create index if not exists ebook_catalog_items_lang_popularity_idx
  on public.ebook_catalog_items(lang_code, source_popularity desc, updated_at desc);

-- Sync state per language (so the backend can show "generatedAt" and avoid concurrent heavy sync runs).
create table if not exists public.ebook_catalog_sync_state (
  lang_code text primary key,
  status text not null default 'idle', -- idle | running | error
  last_started_at timestamptz,
  last_completed_at timestamptz,
  last_error text,
  last_items_upserted integer,
  updated_at timestamptz not null default now()
);

-- Precomputed category counts per language (fast categories list + totals for category pagination).
create table if not exists public.ebook_catalog_category_counts (
  lang_code text not null,
  category text not null,
  count integer not null,
  updated_at timestamptz not null default now(),
  primary key (lang_code, category)
);

create index if not exists ebook_catalog_category_counts_lang_idx
  on public.ebook_catalog_category_counts(lang_code);

-- Precomputed author counts per language (fast top-authors list + totals for author pagination).
create table if not exists public.ebook_catalog_author_counts (
  lang_code text not null,
  author text not null,
  author_norm text not null,
  count integer not null,
  updated_at timestamptz not null default now(),
  primary key (lang_code, author_norm)
);

create index if not exists ebook_catalog_author_counts_lang_idx
  on public.ebook_catalog_author_counts(lang_code);

-- Helper: rebuild category + author counts for a language (run after a sync).
create or replace function public.ebook_catalog_rebuild_counts(p_lang text)
returns void
language plpgsql
as $$
begin
  delete from public.ebook_catalog_category_counts where lang_code = p_lang;
  insert into public.ebook_catalog_category_counts (lang_code, category, count, updated_at)
  select
    lang_code,
    category,
    count(*)::int as count,
    now() as updated_at
  from public.ebook_catalog_items
  where lang_code = p_lang
  group by lang_code, category
  on conflict (lang_code, category) do update
    set count = excluded.count,
        updated_at = excluded.updated_at;

  delete from public.ebook_catalog_author_counts where lang_code = p_lang;
  insert into public.ebook_catalog_author_counts (lang_code, author, author_norm, count, updated_at)
  select
    lang_code,
    min(author) as author,
    author_norm,
    count(*)::int as count,
    now() as updated_at
  from public.ebook_catalog_items
  where lang_code = p_lang
    and author is not null
    and author <> ''
    and lower(author) <> 'unknown'
  group by lang_code, author_norm
  on conflict (lang_code, author_norm) do update
    set author = excluded.author,
        count = excluded.count,
        updated_at = excluded.updated_at;
end;
$$;

-- Safety: ensure every catalog item has a non-blank download URL (so the mobile app can always download later).
do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'ebook_catalog_items_download_url_nonblank'
  ) then
    alter table public.ebook_catalog_items
      add constraint ebook_catalog_items_download_url_nonblank
      check (btrim(download_url) <> '');
  end if;
end;
$$;
